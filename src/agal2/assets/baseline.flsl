
use namespace flare;
use namespace flare.transforms;

// ===================================================================

const float2 m = float2( 0.5,-0.5 );

// ===================================================================

sampler2D diffuseMap;
sampler2D normalMap;
sampler2D specularMap;

sampler2D colorBuffer <mip = 0, wrap = 0>;
sampler2D gBuffer <mip = 0, wrap = 0>;
sampler2D lightBuffer <mip = 0, wrap = 0>;
sampler2D glowBuffer <mip = 0, wrap = 0>;

param NEAR_FAR nearFar;
param float emissive = 0;

technique gbufferColor {
	output vertex = position.xyzw * worldViewProj;
	output fragment = float4( sampler2D( diffuseMap, iUV0 ).rgb, emissive );
}
technique gbufferDepthNormals {
	output vertex = position.xyzw * worldViewProj;
	interpolated float iDepth = (position.xyzw * worldView).z;
	interpolated float3 iNormal = normal * worldView.xyz;
	output fragment = float4( iDepth / nearFar.z, normalize( iNormal.xyz ) * 0.5 + 0.5 );
}

technique quad {
	output vertex = position.xyzw;
	output fragment = sampler2D( colorBuffer, iUV0 );
}

technique emissiveColor {
	output vertex = position.xyzw;
	float4 color = sampler2D( colorBuffer, iUV0 );
	output fragment = float4( color.rgb * color.a, 1 )
}

technique compose {
	
	param float contrast = 2;
	param float4 ambient = float4( 0.4, 0.2, 0.1, 1 );
	param float4 fogColor = float4( 0.1, 0.2, 0.3, 1 );
	
	float4 color = sampler2D( colorBuffer, iUV0 );
	float4 lights = sampler2D( lightBuffer, iUV0 );
	float4 gData = sampler2D( gBuffer, iUV0 );
	float4 glow = sampler2D( glowBuffer, iUV0 );
	
	float fog = gData.x * 0.5;
	fog = saturate( 1 / exp(fog) );
	float3 l = lights.rgb + ambient.rgb;
	float3 r = color.rgb * max( pow( l, contrast ), color.www );
	r += pow( glow.rgb, 0.6 );
	r = lerp( fogColor.rgb, r, fog );
	
	output vertex = position.xyzw;
	output fragment = float4( r, 1 );
}